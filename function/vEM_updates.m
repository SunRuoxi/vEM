function [lambda0_stack, qstack] = vEM_updates(qstack0, nIter, thre, w, img_size, draw, dfactor)
%% ****************************************************************************************************
% Perform one round of vEM (variational inference on q and lambda)
%% Input: initial q distribution (qstack0), number of iterations (nIter)
%% Output: estimated lambda and q distirbution (qstack)
%% Other parameters: 
%%       nIter:     number of variational inference iterations
%%       thre:      soft threholding on lambda
%%       w:         Results(:,4); intensity of FALCON ouput
%%       draw:      '1' to show intemediate results for each iteration; '0' otherwise
%%       img_size:  observed image size 
%%       dfactor:   resolution up-scaled factor
%% ****************************************************************************************************

qstack = qstack0; 
gd = -3:1/dfactor:3; % q's support is 3 image pixels, could change it to a smaller value to make the algorithm faster. 
 
lambda0 = vEM_GetLambda0_weighted(qstack0,[],img_size,dfactor); % initial lambda generated by q0 (from laplace approximation) 
lambda0_stack = []; 
lambda0_stack(:,:,1)= lambda0; % save initial lambda

 
for iter =  1:nIter
    if draw
       iter
    end
 
    for f = 1:length(qstack) % frame 
  
        if qstack(f).nX == 0  % no fluorophore
            continue
        end
   
        idx = qstack(f).frame;  
        prob = qstack(f).ppp;
        nX  = qstack(f).nX;
        xhat =  qstack(f).xhat;  %refined falcon estimate
        Xit = qstack(f).Xit;  %not change
        center = qstack(f).center;  
  
        precision  = inv(qstack(f).sig); %-H
        precision(precision>-0.01&precision<0.01)=0;
  
        X_hat = []; 
        for h = 1:nX 
             X_hat(:,:,h) =  repmat(xhat(h,:), size(Xit(:,:,h),1),1); 
        end
  
        for t = 1:nX % fluorophore index
        
            % expectation 
            EXit = squeeze(sum(Xit .* repmat(prob,1,2,1),1))';  
            EXit_full = []; 
        
            for h = 1:nX
                EXit_full(:,:,h) =  repmat(EXit(h,:), size(Xit(:,:,h),1),1); 
            end
            if sum(eig(precision([t,t+nX],[t,t+nX]))<0)
                %skip unstable precision with negative eigenvalue
                continue  
            end
         
            part1 = -1/2 * (Xit(:,:,t)-X_hat(:,:,t)) * precision([t,t+nX],[t,t+nX])*(Xit(:,:,t)-X_hat(:,:,t))'; 
            part1 = diag(part1);
       
       
            part2 = zeros(length(gd)^2); 
            for j=1:nX
                if j==t
                    continue
                end
                part2 = part2  -  (Xit(:,:,t)-X_hat(:,:,t))* precision([t,t+nX],[j,j+nX])*(EXit_full(:,:,j)-X_hat(:,:,j))'; 
       
            end  
            part2 = diag(part2); 
       
       
            part33 = ceil(Xit(:,:,t)* dfactor);  
            part33 = min( part33,img_size*dfactor); 
            part33 = max( part33,1); 
       
        
            % re-generate image from the new q distribution  
            imim = VB_qDistribution(qstack, f, t, img_size, dfactor);
       
            lambda0_use = lambda0; 
            lambda0_use = max(lambda0_use-thre,0); %soft thresholding on lambda
       
     
            ind = sub2ind([img_size*dfactor,img_size*dfactor], part33(:,1), part33(:,2)); % x,y coordinates associated the q distribution to be updated
            part3 = log(lambda0_use(ind)); 
         
        
       
            % update q distribution 
            part = part1+part2+part3; 
            if max(part)~= -Inf  %new q distribution is not all flat, update regularly. 
                part = part-max(part); 
                temp = exp(part)/sum(exp(part)); 
                if sum(isnan(temp))~=0
                	error(['Frame=', num2str(f), ', fluorophore=', num2str(t), ', q distribution generated NAN!'])
                end 
                prob(:,:,t) =  temp; 
                qstack(f).ppp = prob; %new q 
                im_update = q2image(temp, t, Xit, img_size, dfactor); % transfer new q into image
        
                %update lambda
                lambda0 = lambda0-imim+im_update;  
         
             else  %new q distribution is all flat, asign zero to that q. 
                prob(:,:,t) = zeros([length(gd)^2,1]); 
                qstack(f).ppp = prob;
                
                %update lambda
                lambda0 = lambda0-imim; 
           
             end
        
        end  % end iterate through fluorophores 
   
    end  % end iterate through frames 
 
% save lambda
lambda0_stack(:,:,iter+1) =  max(lambda0-thre,0);

if draw % draw intermediate lambda0 per iteration 
   figure; 
   [im, im_stack] = vEM_GetLambda0_weighted(qstack,w,img_size,dfactor);
   imagesc(im); colorbar; drawnow;
end
 
end % vEM update end

end % function end 